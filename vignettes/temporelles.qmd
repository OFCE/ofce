---
title: "S√©ries temporelles"
vignette: >
  %\VignetteIndexEntry{S√©ries temporelles}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}


format:
  html:
    code-fold: true
    code-summary: "code"

echo: true
message: false
warning: false
---

```{r rinit, include=FALSE}
ofce::init_qmd()
```

## 5 R√®gles d'or

> **R√®gle 1** : On utilise `theme_ofce()` !

> **R√®gle 2** : Les dates sont au format `<date>` m√™me lorsque la fr√©quence est annuelle.

> **R√®gle 3** : On utilise `scale_x_date(date_breaks = "5 years", date_minor_breaks = "1 year", guide = "minor_ticks")` en d√©finissant `date_breaks` √† la fr√©quence souhait√©e (en √©vitant trop de dates) et `date_minor_breaks` √† une ann√©e (`"1 year"`).

> **R√®gle 4** : Si les *y* sont en %, alors mettre "%" dans le format de l'axe des *y*.

> **R√®gle 5** : On choisit un `line_width` entre 0.5 et 1 pour le `geom_line()`, on ajoute un `geom_point(shape=21, stroke=0.25, col="white")` pour marquer les points auxquels on a des donn√©es. Si on peut mettre la l√©gende sous forme de *labels*, c'est mieux car cela all√®ge le graphique.

## Les Donn√©es

Pour les s√©ries temporelles, il y a deux recommandations pour les donn√©es :

1.  utilisez le format long pour les donn√©es du graphique. Il peut √™tre plus simple pour calculer des taux de croissance ou des ratios de passer en format large, mais c'est mieux de passer en format long pour la partie graphique, avec une ou plusieurs colonnes pour diff√©rencier les lignes. Cela permettra d'associer une couleur √† chaque s√©rie et une facette √† chaque pays par exemple.

2.  le champ d√©crivant les dates doit √™tre en type `date`. ce n'est pas toujours √©vident quand les s√©ries sont √† fr√©quence annuelle, mais c'est tr√®s utile pour m√©langer des s√©ries de fr√©quence irr√©guli√®re, pour homog√©n√©iser l'aspect des axes de dates et mieux ma√Ætriser le formatage des dates. Pour convertir une date en date, soit elle est au format `<character>` sous la forme `"2022-12-01"` et la fonction `base::as.Date()` fonctionne tr√®s bien. Sinon, pour les autres cas, le package `{lubridate}` (formation R niv. 1) est tr√®s pratique et propose de nombreuses fonctions permettant d'absorber beaucoup de cas (les fonctions sont par exemple `lubridate::ymd()` `lubridate::dmy()` `lubridate::my()` etc...).

```{r libs}
dates <- c(2023, 2024, 2025)
as.Date(as.character(dates), format  = "%Y")

# si on veut pr√©ciser le jour et le mois de l'ann√©e
as.Date(str_c(dates, "-01-01"))

dates <- c("1/2023", "2/2024", "3/2025")
lubridate::my(dates)
```

::: callout-note
Dans le cas o√π les donn√©es proviennent d'Excel et sont en format num√©rique on peut utiliser `as.Date(df$date, origin = "1899-12-30")` pour les convertir en `<date>`.
:::

Prenons l'exemple du graphiques sur les spreads ([legislatives2024, Blot Geerolf Plane](https://www.ofce-legislatives2024.fr/analyses/spreads.html#fig-spread)). Les donn√©es sont g√©n√©r√©es par un scrapping sur *investing.com* (en attendant une solution API sur une banque de donn√©es bien faite). Les donn√©es se pr√©sentent sous la forme.

```{r spreads}
spreads
```

Les donn√©es sont au format long (avec deux modalit√©s pour `pays` et donc 3 colonnes), les dates sont au format `<date>`, donc tout va presque bien. La colonne `pays` est un peu brute. On la transforme pour avoir un label plus propre et en facteur, pour contr√¥ler l'ordre (on met France en premier, Italie en second). Il y a plusieurs m√©thodes pour arriver √† ce r√©sultat. Ici, on reste tr√®s simple parce qu'il n'y a que deux modalit√©s. Si il y en avait plus de deux (et surtout un grand nombre, possiblement √©volutif), on aurait fait quelques manipulations de cha√Ænes et on aurait utilis√© le package `{countrycode}` pour transformer les code pays en texte lisible, possiblement traduit dans diff√©rentes langues.

```{r spreads_data}
spreads_data <- spreads |>
  distinct(date, pays, .keep_all = TRUE) |>
  mutate(pays = factor( pays, c("spreadfra", "spreadita"), c("France", "Italie")))
spreads
```

## La base du graphique

Le graphique de base est alors simple √† construire. On utilise une couche `geom_line()` et `geom_point()`, une couche `aes()` avec comme `x` les dates, `y` les taux et couleurs les pays. Pour `geom_line()`, il faut pr√©ciser le groupe (cela peut para√Ætre redondant, mais cela peut servir si on veut colorer en fonction d'une autre variable). L'ordre est important et le `geom_line()` est en premier et donc en dessous du `geom_point()`.

```{r base}
library(ofce)
cc <- PrettyCols::prettycols("Summer", n=2)
date_maj <- "2024-07-01"
main <- ggplot(spreads_data) +
  aes(x=date, y=taux, fill = pays, color=pays, group=pays) +
  geom_line(linewidth = 0.75, alpha = 0.5, show.legend = FALSE) +
  geom_point(stroke = 0.5, size = 1,
  col = "white", shape = 21, show.legend = FALSE)+
      scale_color_manual(
        aesthetics = c("fill", "color"),
        name = NULL, values = cc) +
  theme_ofce()+
  guides(
    x = guide_axis(minor.ticks = TRUE),
    y = guide_axis(minor.ticks = TRUE)) +
  labs(
        y="Ecart de taux √† 10 ans",
        x=NULL,
        colour=NULL,
        caption = glue::glue("*Source*¬†: investing.com<br>Mis √† jour¬†: {date_maj}")) +
      scale_x_date(
        labels = scales::label_date_short(format = c("%Y")),
        date_breaks = "5 years",
        date_minor_breaks = "1 year",
        guide = "minor_ticks") +
      scale_y_continuous(
        labels = ~str_c(.x, "%"),
        minor_breaks = scales::breaks_width(0.1),
        guide = "axis_minor")
  main |> add_logo()
```

On utilise la palette *summer* de `{PrettyCols}` (affaire de go√ªt). On utilise la fonction `theme_ofce()` pour homog√©n√©iser la pr√©sentation des graphiques. On pr√©cise les labels des axes inutile pour `x`, explicite pour `y`. Et la source, en notant que l'on peut utiliser `markdown` dans le texte de la source, ce qui permet de mettre *Source* en italique.

Le recours √† `scale_x_date()` permet de sp√©cifier facilement le format des dates (avec la syntaxe de `base::strptime()`) et la fonction `scale::label_date_short()` permet un formatage √©l√©gant des dates (voir plus bas la partie insert).

On ajoute au graphique des annotations. C'est ici faid de fa√ßon laborieuse, on peut construire des fonctions (formation R niv. 2) ou utiliser `{esquisse}` ou `{gganotate}` mais ces deux solutions ont des d√©fauts.

## Les annotations

Pour les annotations on peut utiliser diff√©rentes m√©thodes. La plus laborieuse est la fonction `ggplot2::annotate()`. La plus √©l√©gante est `ggforce::geom_mark_circle()` ou `ggrepel::geom_repel_text()`.

```{r annote}

# m√©thode 1 : annotate

annotations <-  list(
  annotate(
    "text", x = as.Date("2013-12-01"), y= 1,
    label="France" , color=cc[[1]] , size=3, fontface ="bold"),
  annotate(
    "text", x = as.Date("2010-06-01"), y= 3 ,
    label="Italie" , color=cc[[2]], size=3, fontface ="bold"),
  annotate(
    "text",
    x = as.Date("2009-12-01"),
    y= 5 ,
    label="Crise des dettes souveraines\n26 juillet 2012 : Mario Draghi \n 'Whatever it takes'" ,
    color= "grey33",
    size=2,
    hjust=1),
  annotate(
    "segment",
    x = as.Date("2010-03-01"),
    xend = as.Date("2011-07-01"),
    y = 5,
    yend = 4.6,
    colour = "grey33",
    linewidth=0.25,
    arrow= arrow(length = unit(4, "point"))),
  annotate(
    "text",
        x = as.Date("2016-9-01"),
    y= 4.5 ,
    size = 2,
    label="4 mars 2018 : √âlections italiennes\n1er juin : gouvernement de coalition" ,
    color= "grey33"),
  annotate(
    "segment",
    x = as.Date("2016-09-01"),
    xend = as.Date("2018-05-01"),
    y = 4.2,
    yend = 3,
    colour = "grey33",
    linewidth=0.25,
    arrow=arrow(length = unit(4, "point"))),
  annotate(
    "text",
    x = as.Date("2022-01-01"),
    hjust = 1,
    y= 0.8,
    label="Annonce de la dissolution" ,
    color= "grey33",
    size=2),
  annotate(
    "segment",
    x = as.Date("2022-03-01"),
    xend = as.Date("2024-04-01"),
    y = 0.8,
    yend = 0.7,
    colour = "grey33",
    linewidth=0.25,
    arrow= arrow(length = unit(4, "point"))))

(main + annotations) |> add_logo()
```

```{r ggrepel}
# m√©thode 2 : ggrepel
# on enrichit les donn√©es des labels,
# le code est plus compact et surtout plus facile √† manier
# (pour modifier les annotations, on le fait dans les deux tribbles)

library(ggrepel)

events <- tribble(
  ~date, ~pays, ~event,
  "2012-01-02", "Italie", "Crise des dettes souveraines\n26 juillet 2012 : Mario Draghi \n 'Whatever it takes'",
  "2018-06-01", "Italie", "4 mars 2018 : √âlections italiennes\n1er juin : gouvernement de coalition",
  "2024-06-10", "France", "Annonce de la dissolution"
) |>
  mutate(date = as.Date(date) |> floor_date("week", week_start = 1))

label_pays <- tribble(
  ~date, ~pays,
  "2009-01-01", "Italie",
  "2013-12-01", "France"
) |>
  mutate(
    date = as.Date(date),
    date = floor_date(date, "week", week_start = 1),
    label_pays = pays
  )

ss <- spreads_data |>
  left_join(events, by = c("date", "pays")) |>
  left_join(label_pays, by = c("date", "pays")) |>
  mutate(
    label_pays = replace_na(label_pays, ""),
    event = replace_na(event, "")
  ) |>
  arrange(pays, date)

add_logo(main %+% ss) +
  ggrepel::geom_text_repel(
    aes(label = label_pays, color = pays),
    fontface = "bold",
    size = 3, show.legend = FALSE,
    min.segment.length = Inf,
    max.overlaps = Inf, hjust = 0.5
  ) +
  ggrepel::geom_text_repel(
    aes(label = event),
    color = "black",
    size = 2, show.legend = FALSE,
    segment.size = 0.2, min.segment.length = 0.1,
    max.overlaps = Inf, hjust = 0.5,
    nudge_x = c(-500, -250, -250), nudge_y = c(-0.3, 1, -0.5),
    arrow = arrow(length = unit(0.015, "npc"))
  ) +
  scale_y_continuous(labels = ~ str_c(.x, "%"), limits = c(0, 6),
                     minor_breaks = scales::breaks_width(0.1),
                     guide = "axis_minor") +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y")),
    date_breaks = "5 years",
    date_minor_breaks = "1 year",
    guide = "minor_ticks",
    limits = c(as.Date("2008-01-01"), NA))

```

Le r√©sultat est int√©ressant, mais le graphique a cependant un d√©faut, il y a trop de points, ce qui est du √† la fr√©quence quotidienne et donc il perd en clart√©. On va donc faire deux choses : r√©duire la fr√©quence en agr√©geant les donn√©es par mois, puis on va ajouter un insert.

## Fr√©quence mensuelle et insert

Pour construire les donn√©es √† la fr√©quence mensuelle, on va cr√©er un champ de date, mais retenant une seule date par mois (au milieu du mois). En agr√©geant par mois (`summarise`) on construit la s√©rie en mensuel.

```{r mensuelle}
dates <- spreads_data$date
# on force le jour √† √™tre le 15 du mois, il n'y aura qu'une date par mois!
lubridate::day(dates) <- 15
spreads_m <- spreads_data |>
  mutate( date = dates) |>
  group_by(date, pays) |>
  summarize(taux_max = max(taux, na.rm=TRUE),
            taux_min = min(taux, na.rm=TRUE),
            taux = mean(taux, na.rm=TRUE))
spreads_m
```

On peut alors facilement modifier le graphique `main` en utilisant `%+%` (cette instruction modifie les donn√©es en entr√©e du graphique par le nouveau jeu de donn√©es qu'on vient de construire qui a exactement la m√™me structure, comme on a utilis√© les dates le passage du quotidien au mensuel se fait automatiquement, les axes sont parfaitement construits) :

```{r logo}
add_logo(main %+% spreads_m)
```

L'*insert* est le m√™me graphique, en enlevant les annotations, en simplifiant les axes et en zoomant sur les deux derniers mois.

```{r insert}
inset <- main +
  theme_ofce(
    base_size = 7,
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    plot.background = element_rect(fill = "white")
  ) +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y", "%B")),
    date_breaks = "1 month",
    limits = c(Sys.Date() - months(2), NA),
    guide = "minor_ticks"
  ) +
  geom_vline(
    xintercept = as.Date("2024-06-09"),
    linewidth = 0.1,
    color = "grey50"
  ) +
  geom_vline(
    xintercept = as.Date("2024-07-08"),
    linewidth = 0.1,
    color = "grey50"
  ) +
  scale_y_continuous(labels = ~ str_c(.x, "%"), limits = c(0, 2),
                     minor_breaks = scales::breaks_width(0.1),
                     guide = "axis_minor") +
  labs(y = NULL, caption = NULL, color = NULL, fill = NULL)
inset
```

On l'ins√®re dans le graphique principal en utilisant `{patchwork}`, ce qui donne le graphique, plus lisible et plus √©l√©gant. Les param√®tres de `inset` sont choisis apr√®s quelques essais et erreurs. On a r√©duit la taille de la police de caract√®re pour accentuer l'effet visuel.

```{r patchwork}
library(patchwork)
main_m <- add_logo((main + annotations) %+% spreads_m)
main_m  + inset_element(inset, 0.75, 0.66, 1, 1)
```

::: {#tip-id .callout-tip collapse="true" appearance="minimal" icon="false"}
## Une alternative avec {ggmagnify}

Le package `{ggmagnify}` simplifie la t√¢che et offre quelques am√©liorations esth√©tiques. Il faut cependant que les *dataset* principal et *inset* soit les m√™mes \[pas s√ªr en fait\]. On reprend l'agr√©gation temporelle en l'arr√™tant aux deux derniers mois. On complexifie l'insert pour int√©grer plus d'√©l√©ments en utilisant l'argument `plot` de `ggmagnify::geom_magnify()`.

```{r ggmagnify}
# pak::pak("hughjonesd/ggmagnify")
library(ggmagnify)

spreads_hyb <- spreads_data |>
  mutate(
    agg = date < now() - months(2),
    date_h = floor_date(date, unit = "month"),
    date_h = if_else(agg, date_h, date)
  ) |>
  group_by(date_h, pays) |>
  summarize(
    taux = mean(taux, na.rm = TRUE),
    n = n(), .groups = "drop"
  ) |>
  rename(
    date = date_h
  ) |>
  mutate(
    date_label = ifelse(n > 1,
      stamp(
        orders = "%B %Y",
        locale = "fr_FR.utf8", exact = TRUE, quiet = TRUE
      )(date),
      stamp("22/12/2024",
        orders = "%d/%m/%Y",
        locale = "fr_FR.utf8", quiet = TRUE
      )(date)
    ),
    tooltip = str_c(
      "<b>", pays, "</b><br>",
      date_label,
      "<br>Ecart de taux avec l'Allemagne : ", f_taux(taux)
    ),
  )
inset_plot <- ggplot(spreads_hyb) +
  aes(x = date, y = taux, fill = pays, color = pays, group = pays) +
  geom_line(linewidth = 0.75, alpha = 0.5, show.legend = FALSE) +
  geom_point_interactive(
    aes(tooltip = tooltip, data_id = date),
    stroke = 0.5, size = 1,
    col = "white", shape = 21, show.legend = FALSE
  ) +
  scale_color_manual(
    aesthetics = c("fill", "color"),
    name = NULL, values = cc
  ) +
  theme_ofce(
    base_size = 7,
    panel.grid.major.y = element_line(color = "gray", linewidth = 0.25),
    axis.line = element_blank()
  ) +
  geom_vline(xintercept = as.Date("2024-6-30"), linewidth = 0.25, color = "grey") +
  labs(
    y = NULL,
    x = NULL,
    colour = NULL,
    caption = NULL
  ) +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y", "%B")),
    date_breaks = "1 month"
  ) +
  scale_y_continuous(
    labels = ~ str_c(.x, "%"), breaks = seq(0, 2))

md <- max(spreads_hyb$date)
from <- list(md - days(50), md, 0, 2)
to <- list(md - years(4), md + years(1), 3.75, 5)
sh <- ggplot(spreads_hyb) +
  aes(x = date, y = taux, fill = pays, color = pays, group = pays) +
  geom_line(linewidth = 0.75, alpha = 0.5, show.legend = FALSE) +
  geom_point_interactive(
    aes(tooltip = tooltip, data_id = date),
    stroke = 0.5, size = 1,
    col = "white", shape = 21, show.legend = FALSE
  ) +
  scale_color_manual(
    aesthetics = c("fill", "color"),
    name = NULL, values = cc
  ) +
  theme_ofce(plot.margin = ggplot2::margin(10, 60, 10, 10)) +
  guides(
    x = guide_axis(minor.ticks = TRUE),
    y = guide_axis(minor.ticks = TRUE)
  ) +
  labs(
    y = "Ecart de taux √† 10 ans",
    x = NULL,
    colour = NULL,
    caption = glue::glue("*Source*¬†: investing.com<br>Mis √† jour¬†: {date_maj}")
  ) +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y")),
    date_breaks = "5 years",
    date_minor_breaks = "1 year",
    guide = "minor_ticks"
  ) +
  scale_y_continuous(
    labels = ~ str_c(.x, "%"), breaks = seq(0, 5),
    minor_breaks = scales::breaks_width(0.1),
    guide = "axis_minor",
    expand = expansion(), limits = c(-0.25, NA),
  ) +
  annotations +
  coord_cartesian(clip = "off") +
  ggmagnify::geom_magnify(
    from = from, to = to, linewidth = 0.1,
    colour = "grey25", shadow = TRUE,
    plot = inset_plot, axes = "xy",
    shadow.args = list(sigma = 5, colour = "grey80", x_offset = 5, y_offset = 5)
  )

girafy(add_logo(sh), r = 2.5)
```
:::

## L'interactivit√©

La derni√®re √©tape est l'interactivit√©. On utilise le package `{ggiraph}` qui va permettre d'int√©grer des *tooltips* tr√®s simplement et tr√®s efficacement. On peut aussi avec des s√©lections dynamiques ou encore des zooms.

Pour ajouter l'interactivit√©, la premi√®re √©tape est de g√©n√©rer le texte des *tooltips* dans le tableau de donn√©es. Notez l'utilisation de `lubridate::stamp_date()` pour formater les dates simplement.

```{r tooltip}
spreads_m <- spreads_m |>
  mutate(
    tooltip = str_c("<b>", pays, "</b><br>",
                    stamp(exact = TRUE, orders = "%B %Y",
                          locale = "fr_FR.utf8", quiet = TRUE)(date),
                    "<br>Ecart de taux avec l'Allemagne : ", f_taux(taux)))
```

L'interactivit√© est alors ajout√©e par des instructions sp√©cifiques qui se substituent aux `geom_*` en ajoutant un suffix, `geom_*_interactive`. Ces `geom_*_interactive` acceptent un `aes` avec deux param√®tres suppl√©mentaire, le premier d√©finissant le `tooltip` et le second, `data_id`, une variable qui relie les √©l√©ments graphiques entre eux pour qu'ils soient modifi√©s lors du survol avec la souris. La fonction `girafy` qui est d√©finie par `source("rinit.r")` et finalise le rendu. `{ggiraph}` conserve tous les √©l√©ments du graphique et il est possible de l'appliquer avec `{patchwork}` pour combiner les interactivit√©s.

```{r interactif}
library(ggiraph)
main_i <- ggplot(spreads_m) +
  aes(x = date, y = taux, color = pays, group = pays, fill = pays) +
  geom_line(linewidth = 0.75, alpha = 0.5, show.legend = FALSE) +
  geom_point_interactive(aes(tooltip = tooltip, data_id = date),
    stroke = 0.5, size = 1, col = "white", shape = 21,
    hover_nearest = TRUE, show.legend = FALSE
  ) +
  scale_color_manual(name = NULL, values = cc, aesthetics = c("fill", "color")) +
  labs(
    y = "Ecart de taux √† 10 ans",
    x = NULL,
    caption = "Source: investing.com"
  ) +
  theme_ofce() +
  guides(
    x = guide_axis(minor.ticks = TRUE),
    y = guide_axis(minor.ticks = TRUE)
  ) +
  labs(
    colour = NULL,
    caption = glue::glue("*Source*¬†: investing.com<br>Mis √† jour¬†: {date_maj}")
  ) +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y", "%B")),
    date_breaks = "5 years",
    date_minor_breaks = "1 year",
    guide = "minor_ticks"
  ) +
  scale_y_continuous(labels = ~ str_c(.x, "%"))

spreads_data <- spreads_data |>
  mutate(
    tooltip = str_c(
      "<b>", pays, "</b><br>",
      stamp_date("24/7/2024", locale = "fr_FR.utf8", quiet = TRUE)(date),
      "<br>Ecart de taux avec l'Allemagne : ", f_taux(taux)
    )
  )

inset_i <- (main_i %+% spreads_data) +
  theme_ofce(
    base_size = 7,
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    plot.background = element_rect(fill = "white")
  ) +
  scale_x_date(
    labels = scales::label_date_short(format = c("%Y", "%B")),
    date_breaks = "1 month",
    date_minor_breaks = "1 week",
    limits = c(Sys.Date() - months(2), NA),
    guide = "minor_ticks"
  ) +
  geom_vline(
    xintercept = as.Date("2024-06-09"),
    linewidth = 0.1,
    color = "grey50"
  ) +
  scale_y_continuous(labels = ~ str_c(.x, "%"), 
                     limits = c(0, 2), 
                     minor_breaks = scales::breaks_width(0.1),
                     guide = "axis_minor") +
  labs(y = NULL, caption = NULL, color = NULL, fill = NULL)

main_i <- ((main_i + annotations) %+% spreads_m) |> add_logo()
main_i <- main_i + inset_element(inset_i, 0.75, 0.66, 1, 1)
girafy(main_i, r = 2.5)
```

La clef pour l'interactivit√© est d'apporter de l'information √† l'utilisateur par le texte du *tooltip*. Il est possible d'avoir des interactivit√©s plus avanc√©es, en d√©clenchant une action sur un *click* par exemple. L'approche par `{ggiraph}` est applicable simplement √† de nombreux graphiques avec un rendu satisfaisant. Cela marche √©galement pour des `facet` et donc √ßa ouvre beaucoup de possibilit√©s.

## Fr√©quence trimestrielle

On transforme les donn√©es en fr√©quence trimestrielle en utilisant la fonction `lubridate::floor_date()`. En calculant les variables ann√©e (`y`) et trimestre (`q`), on peut avec le package `{ggh4x}` produire facilement un joli graphique trimestriel. Les clefs sont de mettre en x l'interaction entre ces deux √©l√©ments discrets (attention √† l'ordre, attention √† trier les donn√©es avec `arrange`). La magie op√®re ensuite avec `guide = "axis_nested"`. Cete fonction est g√©n√©ralisable √† bien des cas.

```{r trim}
library(lubridate)
# pak::pak("teunbrand/ggh4x")
library(ggh4x)

spreads_q <- spreads_data |>
  mutate(
    y = lubridate::year(date),
    q = str_c("T", lubridate::quarter(date)),
    date_q = lubridate::floor_date(date, unit = "quarter")
  ) |>
  group_by(date_q, y, q, pays) |>
  summarize(
    taux_max = max(taux, na.rm = TRUE),
    taux_min = min(taux, na.rm = TRUE),
    taux = mean(taux, na.rm = TRUE), .groups = "drop"
  ) |>
  rename(date = date_q) |>
  arrange(date) |>
  filter(date >= "2018-01-01")

(ggplot(spreads_q) +
  aes(x = interaction(q, y), y = taux, fill = pays, color = pays, group = pays) +
  geom_line(linewidth = 0.75, alpha = 0.5, show.legend = FALSE) +
  geom_point(
    stroke = 0.5, size = 1,
    col = "white", shape = 21, show.legend = FALSE
  ) +
  scale_color_manual(
    aesthetics = c("fill", "color"),
    name = NULL, values = cc
  ) +
  theme_ofce(
    axis.text.x = element_text(size = rel(0.8), margin = margin(t = 6)),
    ggh4x.axis.nesttext.x = element_text(size = rel(1.2), margin = margin(t = 3))
  ) +
  labs(
    y = "Ecart de taux √† 10 ans",
    x = NULL,
    colour = NULL,
    caption = glue::glue("*Source*¬†: investing.com<br>Mis √† jour¬†: {date_maj}")
  ) +
  scale_y_continuous(labels = ~ str_c(.x, "%"),
                     minor_breaks = scales::breaks_width(0.1),
                     guide = "axis_minor") +
  scale_x_discrete(guide = "axis_nested")) |> add_logo()
```

## Double √©chelle

Non mais ca va pas ?

## Une derni√®re chose : la mise √† dispostion des donn√©es

Une bonne pratique est de mettre √† disposition les donn√©es et le code ayant servi √† produire le graphique. Une fa√ßon est d'utiliser les boutons code pr√©sents dans ce document pour publier le code. La seconde est de mettre tous les codes sur un d√©p√¥t github üò∏ public.

A minima, on ajoute un bouton pour t√©l√©charger les donn√©es. C'est simple √† faire avec `{downloadthis}` et ce bout de code qui peut √™tre mis juste apr√®s un graphique. On reprend le fichier de donn√©es, tel quel, modifi√© √©ventuellement pour enlever ou renommer une colonne, et qui sera disponible en csv, UTF8, avec des virgules comme s√©p√©rateurs et des points comme marque d√©cimale (i.e. pas ce qu'Excel attend ‚ò†Ô∏è).

Pour que les boutons soient sur la m√™me ligne on utilise la syntaxe *inline* `'r une_expression_R'` :

```{r}
library(downloadthis)
b1 <- download_this(
  spreads_m |> select(-tooltip),
  icon = "fa fa-download",
  class = "dbtn",
  button_label  = "Taux mensuels",
  output_name = "taux_mensuels"
)
b2 <- download_this(
  spreads_data,
  icon = "fa fa-download",
  class = "dbtn",
  button_label  = "Taux quotidiens",
  output_name = "taux_quotidiens"
)
```

`r b1` `r b2`

On peut aussi les mettre dans la marge en entourant le chunk R de `::: column-margin ‚èé un_code_r ‚èé :::` (visuellement c'est mieux quand il y a le graphique juste avant le div).