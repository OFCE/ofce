[
  {
    "objectID": "cache.html",
    "href": "cache.html",
    "title": "Cache",
    "section": "",
    "text": "Sys.getenv(\"QUARTO_PROJECT_ROOT\")\n\n[1] \"/Users/xt/GitHub/ofce/work/cache\"\n\nSys.getenv(\"QUARTO_DOCUMENT_PATH\")\n\n[1] \"/Users/xt/GitHub/ofce/work/cache\"\n\n\n\n\n\nTable 1\n\n\n\nCalled from: source_data(\"testsource.R\", track = list(\"data.csv\"), quiet = FALSE)\ndebug: new_qmds &lt;- unique(c(qmds, qmd_file))\ndebug: if (force & !prevent) {\n    our_data &lt;- exec_source(src, exec_wd, args)\n    if (our_data$ok) {\n        our_data$lapse &lt;- lapse\n        our_data$src &lt;- relname\n        our_data$src_hash &lt;- src_hash\n        our_data$arg_hash &lt;- arg_hash\n        our_data$track_hash &lt;- list(track_hash)\n        our_data$wd &lt;- wd\n        our_data$qmd_file &lt;- new_qmds\n        our_data$root &lt;- root\n        our_data$cache &lt;- cache_rep\n        cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n            uid = uid)\n        if (metadata) {\n            return(our_data)\n        }\n        else {\n            return(our_data$data)\n        }\n    }\n    else {\n        if (!quiet) \n            cli::cli_alert_warning(\"le fichier {src} retourne une erreur, on cherche dans le cache\")\n    }\n}\ndebug: meme_null &lt;- function(x, n, def = 0) ifelse(is.null(x[[n]]), \n    def, x[[n]])\ndebug: if (hash & !prevent) good_datas &lt;- purrr::keep(purrr::keep(purrr::keep(good_datas, \n    ~meme_null(.x, \"src_hash\") == src_hash), ~meme_null(.x, \"arg_hash\", \n    digest::digest(list())) == arg_hash), ~meme_null(.x, \"track_hash\") == \n    track_hash)\ndebug: good_datas &lt;- purrr::keep(purrr::keep(purrr::keep(good_datas, \n    ~meme_null(.x, \"src_hash\") == src_hash), ~meme_null(.x, \"arg_hash\", \n    digest::digest(list())) == arg_hash), ~meme_null(.x, \"track_hash\") == \n    track_hash)\ndebug: if (lapse != \"never\" & !prevent) {\n    alapse &lt;- what_lapse(lapse)\n    good_datas &lt;- purrr::keep(good_datas, ~lubridate::now() - \n        .x[[\"date\"]] &lt;= alapse)\n}\ndebug: if (length(good_datas) == 0) {\n    if (prevent) {\n        if (!quiet) \n            cli::cli_alert_warning(\"Pas de données en cache et pas d'exécution\")\n        return(NULL)\n    }\n    our_data &lt;- exec_source(src, exec_wd, args)\n    if (our_data$ok) {\n        our_data$lapse &lt;- lapse\n        our_data$src &lt;- relname\n        our_data$src_hash &lt;- src_hash\n        our_data$qmd_file &lt;- new_qmds\n        our_data$arg_hash &lt;- arg_hash\n        our_data$track_hash &lt;- list(track_hash)\n        our_data$root &lt;- root\n        our_data$cache &lt;- cache_rep\n        cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n            uid = uid)\n        if (metadata) {\n            return(our_data)\n        }\n        else {\n            return(our_data$data)\n        }\n    }\n    else {\n        if (!quiet) \n            cli::cli_alert_warning(\"le fichier {src} retourne une erreur et rien dans le cache\")\n        return(NULL)\n    }\n}\ndebug: dates &lt;- purrr::map(good_datas, \"date\")\ndebug: good_good_data &lt;- good_datas[[which.max(dates)]]\ndebug: if (!quiet) cli::cli_alert_warning(\"Données lues dans {.file {names(good_datas)[[which.max(dates)]]}}\")\ndebug: cli::cli_alert_warning(\"Données lues dans {.file {names(good_datas)[[which.max(dates)]]}}\")\n\n\ndebug: ggd_lapse &lt;- good_good_data$lapse %||% \"never\"\ndebug: ggd_wd &lt;- good_good_data$wd %||% \"file\"\ndebug: ggd_qmds &lt;- setequal(good_good_data$qmd_file, new_qmds)\ndebug: if (ggd_lapse != lapse | ggd_wd != wd | !ggd_qmds) {\n    good_good_data$lapse &lt;- lapse\n    good_good_data$wd &lt;- wd\n    good_good_data$qmd_file &lt;- new_qmds\n    cache_data(good_good_data, cache_rep = full_cache_rep, name = basename, \n        uid = uid)\n}\ndebug: good_good_data$lapse &lt;- lapse\ndebug: good_good_data$wd &lt;- wd\ndebug: good_good_data$qmd_file &lt;- new_qmds\ndebug: cache_data(good_good_data, cache_rep = full_cache_rep, name = basename, \n    uid = uid)\ndebug: if (metadata) {\n    return(good_good_data)\n} else {\n    return(good_good_data$data)\n}\ndebug: return(good_good_data$data)\n\n\n[[1]]\n[1] \"/Users/xt/GitHub/ofce/work/cache/cache2.qmd\"\n[2] \"/Users/xt/GitHub/ofce/work/cache/cache.qmd\" \n\n\n\n\ntexte avant\n\n\n\n\n\n\ntitre de l’encadré\n\n\n\n\n\n\nlibrary(tidyverse)\nggplot(cars)+geom_point(aes(x=speed, y=dist))+ofce::theme_ofce()\n\n\n\n\n\n\n\n\nblablbl\n\n\n\n\n\n\n\n\na\nb\nc\n\n\n\n\ntext\n1\nLong text aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh\n\n\nothers\n2\nLong text aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh\n\n\n\n\n\n\n\n\n\n\ncontinuing"
  },
  {
    "objectID": "cache2.html",
    "href": "cache2.html",
    "title": "Cache",
    "section": "",
    "text": "Sys.getenv(\"QUARTO_PROJECT_ROOT\")\n\n[1] \"/Users/xt/GitHub/ofce/work/cache\"\n\nSys.getenv(\"QUARTO_DOCUMENT_PATH\")\n\n[1] \"/Users/xt/GitHub/ofce/work/cache\"\n\nknitr::current_input()\n\n[1] \"cache2.rmarkdown\"\n\n\n\n\n\nTable 1\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(ofce)\ndd &lt;- source_data(\"testsource.R\", track=list(\"data.csv\"), quiet = FALSE)\n\nℹ root: '/Users/xt/GitHub/ofce/work/cache'\nℹ uid: f93d1f65\nℹ cache: '/Users/xt/GitHub/ofce/work/cache/.data'\nℹ '/Users/xt/GitHub/ofce/work/cache/testsource.r' comme source\n\n\nCalled from: source_data(\"testsource.R\", track = list(\"data.csv\"), quiet = FALSE)\ndebug: new_qmds &lt;- unique(c(qmds, qmd_file))\ndebug: if (force & !prevent) {\n    our_data &lt;- exec_source(src, exec_wd, args)\n    if (our_data$ok) {\n        our_data$lapse &lt;- lapse\n        our_data$src &lt;- relname\n        our_data$src_hash &lt;- src_hash\n        our_data$arg_hash &lt;- arg_hash\n        our_data$track_hash &lt;- list(track_hash)\n        our_data$wd &lt;- wd\n        our_data$qmd_file &lt;- new_qmds\n        our_data$root &lt;- root\n        our_data$cache &lt;- cache_rep\n        cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n            uid = uid)\n        if (metadata) {\n            return(our_data)\n        }\n        else {\n            return(our_data$data)\n        }\n    }\n    else {\n        if (!quiet) \n            cli::cli_alert_warning(\"le fichier {src} retourne une erreur, on cherche dans le cache\")\n    }\n}\ndebug: meme_null &lt;- function(x, n, def = 0) ifelse(is.null(x[[n]]), \n    def, x[[n]])\ndebug: if (hash & !prevent) good_datas &lt;- purrr::keep(purrr::keep(purrr::keep(good_datas, \n    ~meme_null(.x, \"src_hash\") == src_hash), ~meme_null(.x, \"arg_hash\", \n    digest::digest(list())) == arg_hash), ~meme_null(.x, \"track_hash\") == \n    track_hash)\ndebug: good_datas &lt;- purrr::keep(purrr::keep(purrr::keep(good_datas, \n    ~meme_null(.x, \"src_hash\") == src_hash), ~meme_null(.x, \"arg_hash\", \n    digest::digest(list())) == arg_hash), ~meme_null(.x, \"track_hash\") == \n    track_hash)\ndebug: if (lapse != \"never\" & !prevent) {\n    alapse &lt;- what_lapse(lapse)\n    good_datas &lt;- purrr::keep(good_datas, ~lubridate::now() - \n        .x[[\"date\"]] &lt;= alapse)\n}\ndebug: if (length(good_datas) == 0) {\n    if (prevent) {\n        if (!quiet) \n            cli::cli_alert_warning(\"Pas de données en cache et pas d'exécution\")\n        return(NULL)\n    }\n    our_data &lt;- exec_source(src, exec_wd, args)\n    if (our_data$ok) {\n        our_data$lapse &lt;- lapse\n        our_data$src &lt;- relname\n        our_data$src_hash &lt;- src_hash\n        our_data$qmd_file &lt;- new_qmds\n        our_data$arg_hash &lt;- arg_hash\n        our_data$track_hash &lt;- list(track_hash)\n        our_data$root &lt;- root\n        our_data$cache &lt;- cache_rep\n        cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n            uid = uid)\n        if (metadata) {\n            return(our_data)\n        }\n        else {\n            return(our_data$data)\n        }\n    }\n    else {\n        if (!quiet) \n            cli::cli_alert_warning(\"le fichier {src} retourne une erreur et rien dans le cache\")\n        return(NULL)\n    }\n}\ndebug: if (prevent) {\n    if (!quiet) \n        cli::cli_alert_warning(\"Pas de données en cache et pas d'exécution\")\n    return(NULL)\n}\ndebug: our_data &lt;- exec_source(src, exec_wd, args)\n\n\nUsing libcurl 8.7.1 with LibreSSL/3.3.6\n\nAttaching package: 'curl'\n\nThe following object is masked from 'package:readr':\n\n    parse_date\n\nNew names:\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `nombre_transactions = as.numeric(nombre_transactions)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\ndebug: if (our_data$ok) {\n    our_data$lapse &lt;- lapse\n    our_data$src &lt;- relname\n    our_data$src_hash &lt;- src_hash\n    our_data$qmd_file &lt;- new_qmds\n    our_data$arg_hash &lt;- arg_hash\n    our_data$track_hash &lt;- list(track_hash)\n    our_data$root &lt;- root\n    our_data$cache &lt;- cache_rep\n    cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n        uid = uid)\n    if (metadata) {\n        return(our_data)\n    }\n    else {\n        return(our_data$data)\n    }\n} else {\n    if (!quiet) \n        cli::cli_alert_warning(\"le fichier {src} retourne une erreur et rien dans le cache\")\n    return(NULL)\n}\ndebug: our_data$lapse &lt;- lapse\ndebug: our_data$src &lt;- relname\ndebug: our_data$src_hash &lt;- src_hash\ndebug: our_data$qmd_file &lt;- new_qmds\ndebug: our_data$arg_hash &lt;- arg_hash\ndebug: our_data$track_hash &lt;- list(track_hash)\ndebug: our_data$root &lt;- root\ndebug: our_data$cache &lt;- cache_rep\ndebug: cache_data(our_data, cache_rep = full_cache_rep, name = basename, \n    uid = uid)\ndebug: if (metadata) {\n    return(our_data)\n} else {\n    return(our_data$data)\n}\ndebug: return(our_data$data)\n\nsource_data_status()$qmd_file\n\n[[1]]\n[1] \"/Users/xt/GitHub/ofce/work/cache/cache2.qmd\"\n\n\n\n\ntexte avant\n\n\n\n\n\n\ntitre de l’encadré\n\n\n\n\n\n\nlibrary(tidyverse)\nggplot(cars)+geom_point(aes(x=speed, y=dist))+ofce::theme_ofce()\n\n\n\n\n\n\n\n\nblablbl\n\n\n\n\n\n\n\n\na\nb\nc\n\n\n\n\ntext\n1\nLong text aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh\n\n\nothers\n2\nLong text aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh\n\n\n\n\n\n\n\n\n\n\ncontinuing"
  }
]